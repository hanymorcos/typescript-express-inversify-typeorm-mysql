{"version":3,"sources":["../../src/decorator/Index.ts"],"names":[],"mappings":";;AAAA,kCAAgD;AAkChD;;GAEG;AACH,eAAsB,qBAA4E,EAC5E,oBAAqE,EACrE,YAA2B;IAC7C,IAAM,IAAI,GAAG,OAAO,qBAAqB,KAAK,QAAQ,GAAG,qBAAqB,GAAG,SAAS,CAAC;IAC3F,IAAM,MAAM,GAAG,OAAO,qBAAqB,KAAK,QAAQ,GAAuC,oBAAoB,GAAG,qBAAiC,CAAC;IACxJ,IAAI,OAAO,GAAG,CAAC,OAAO,qBAAqB,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC,GAAG,qBAAqC,GAAG,YAAY,CAAC;IAC1J,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;QACT,OAAO,GAAG,CAAC,OAAO,oBAAoB,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC,GAAG,qBAAqC,GAAG,YAAY,CAAC;IAExJ,MAAM,CAAC,UAAU,WAA4B,EAAE,YAAqB;QAChE,IAAM,IAAI,GAAsB;YAC5B,MAAM,EAAE,YAAY,GAAG,WAAW,CAAC,WAAW,GAAG,WAAuB;YACxE,IAAI,EAAE,IAAI;YACV,OAAO,EAAE,YAAY,GAAG,CAAC,YAAY,CAAC,GAAG,MAAM;YAC/C,MAAM,EAAE,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,IAAI,GAAG,KAAK;SACnD,CAAC;QACF,8BAAsB,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/C,CAAC,CAAC;AACN,CAAC;AAlBD,sBAkBC","file":"Index.js","sourcesContent":["import {getMetadataArgsStorage} from \"../index\";\nimport {IndexMetadataArgs} from \"../metadata-args/IndexMetadataArgs\";\nimport {IndexOptions} from \"./options/IndexOptions\";\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(name: string, options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(name: string, fields: string[], options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(fields: string[], options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(fields: (object: any) => any[], options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(name: string, fields: (object: any) => any[], options?: IndexOptions): Function;\n\n/**\n * Composite index must be set on entity classes and must specify entity's fields to be indexed.\n */\nexport function Index(nameOrFieldsOrOptions: string|string[]|((object: any) => any[])|IndexOptions,\n                      maybeFieldsOrOptions?: ((object: any) => any[])|IndexOptions|string[],\n                      maybeOptions?: IndexOptions): Function {\n    const name = typeof nameOrFieldsOrOptions === \"string\" ? nameOrFieldsOrOptions : undefined;\n    const fields = typeof nameOrFieldsOrOptions === \"string\" ? <((object: any) => any[])|string[]> maybeFieldsOrOptions : nameOrFieldsOrOptions as string[];\n    let options = (typeof nameOrFieldsOrOptions === \"object\" && !Array.isArray(nameOrFieldsOrOptions)) ? nameOrFieldsOrOptions as IndexOptions : maybeOptions;\n    if (!options)\n        options = (typeof maybeFieldsOrOptions === \"object\" && !Array.isArray(maybeFieldsOrOptions)) ? nameOrFieldsOrOptions as IndexOptions : maybeOptions;\n\n    return function (clsOrObject: Function|Object, propertyName?: string) {\n        const args: IndexMetadataArgs = {\n            target: propertyName ? clsOrObject.constructor : clsOrObject as Function,\n            name: name,\n            columns: propertyName ? [propertyName] : fields,\n            unique: options && options.unique ? true : false\n        };\n        getMetadataArgsStorage().indices.add(args);\n    };\n}\n"],"sourceRoot":".."}