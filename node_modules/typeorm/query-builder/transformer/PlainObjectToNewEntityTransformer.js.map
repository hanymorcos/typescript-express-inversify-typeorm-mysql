{"version":3,"sources":["../../src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts"],"names":[],"mappings":"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","file":"PlainObjectToNewEntityTransformer.js","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T>(newEntity: T, object: ObjectLiteral, metadata: EntityMetadata): T {\n        this.groupAndTransform(newEntity, object, metadata);\n        return newEntity;\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(entity: any, object: ObjectLiteral, metadata: EntityMetadata): void {\n\n        // copy regular column properties from the given object\n        metadata.allColumns\n            .filter(column => object.hasOwnProperty(column.propertyName))\n            .forEach(column => entity[column.propertyName] = object[column.propertyName]); // todo: also need to be sure that type is correct\n\n        // if relation is loaded then go into it recursively and transform its values too\n        metadata.allRelations\n            .filter(relation => object.hasOwnProperty(relation.propertyName))\n            .forEach(relation => {\n                const relationMetadata = relation.inverseEntityMetadata;\n                if (!relationMetadata)\n                    throw new Error(\"Relation metadata for the relation \" + metadata.name + \"#\" + relation.propertyName + \" is missing\");\n\n                if (relation.isManyToMany || relation.isOneToMany) {\n                    if (object[relation.propertyName] instanceof Array) {\n                        entity[relation.propertyName] = object[relation.propertyName].map((subObject: any) => {\n                            let subEntity = relationMetadata.create();\n                            // todo: support custom initial fields here\n                            if (entity[relation.propertyName] instanceof Array) {\n                                const existRelation = entity[relation.propertyName].find((subEntity: any) => {\n                                    return subEntity[relation.referencedColumnName] === subObject[relation.referencedColumnName];\n                                });\n                                if (existRelation)\n                                    this.groupAndTransform(subEntity, existRelation, relationMetadata);\n                            }\n\n                            this.groupAndTransform(subEntity, subObject, relationMetadata);\n                            return subEntity;\n                        });\n                    } else {\n                        entity[relation.propertyName] = object[relation.propertyName];\n                    }\n                } else {\n                    if (object[relation.propertyName]) {\n                        const subEntity = relationMetadata.create();\n                        if (entity[relation.propertyName])\n                            this.groupAndTransform(subEntity, entity[relation.propertyName], relationMetadata);\n\n                        this.groupAndTransform(subEntity, object[relation.propertyName], relationMetadata);\n                        entity[relation.propertyName] = subEntity;\n                    } else {\n                        entity[relation.propertyName] = object[relation.propertyName];\n                    }\n                }\n            });\n    }\n\n}"],"sourceRoot":"../.."}